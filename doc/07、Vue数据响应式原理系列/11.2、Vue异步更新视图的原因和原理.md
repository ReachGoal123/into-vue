### 一、Vue 为什么要异步更新视图？

我们在开发过程中经常遇到这样的场景：

场景一：短时间内多次更新某个数据

``` html
<template>
  <div>{{num}}</div>
</template>
```

``` javascript
export default {
  data () {
    return {
      num: 1
    }
  },

  methods: {
    change () {
      for (let i = 0; i < 10; i += 1) {
        this.num += 1;
      }
    }
  }
}
```

假设 Vue 同步更新数据，num 在段时间内变化了 10 次，那么会依次执行 set -> notify -> update -> patch 10次，最重要的就是 patch 这块，因为 Vue 更新视图其实就是操作 dom（将 vnode 渲染为实际 dom），频繁操作 dom 的代码是非常昂贵的，所以，同步更新视图不靠谱，想办法用异步解决。

当 Vue 采用异步更新视图的策略后，以下场景又有问题，我们看到最后打印的 innerText， num 并不是新值 2，而是旧值 1。

场景二：修改某个字段值之后，立刻获取 dom 最新值

``` html
<template>
  <div ref="container">{{num}}</div>
</template>
```

``` javascript
export default {
  data () {
    return {
      num: 1
    }
  },
  
  methods: {
    change () {
      this.nun = 2;
      console.log(this.num); // 2
      console.log(this.$refs.container.innerText); // 1
    }
  }
}
```

基于以上场景二出现的问题，Vue 为我们提供了 nextTick 方法，而 nextTick 同时也是解决场景一中异步的策略。

### 关于 JavaScript 异步机制，EventLoop 的概念及 Loop 过程，可参考以下 demo 及 文档：

[https://github.com/zymfe/test-code/blob/master/test29.js](https://github.com/zymfe/test-code/blob/master/test29.js)

[https://github.com/zymfe/test-code/blob/master/test72.js](https://github.com/zymfe/test-code/blob/master/test72.js)

[https://github.com/zymfe/test-code/blob/master/test61.html](https://github.com/zymfe/test-code/blob/master/test61.html)

[https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

[https://nodejs.org/en/blog/release/v0.10.0/#faster-process-nexttick](https://nodejs.org/en/blog/release/v0.10.0/#faster-process-nexttick)

总结以上内容，顺便为下面 Vue 实现 nextTick 原理做准备：

JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver 的回调会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，只能用 setTimeout 创建 task 了。为啥要用 microtask？根据HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。

### Vue 实现异步更新数据的原理：nextTick


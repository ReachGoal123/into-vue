接着上节笔记，实例化 Watcher 的具体过程：

``` javascript
new Watcher(vm, updateComponent, noop, null, true);
```

首先判断是否是渲染 Watcher，如果是，则将当前 Watcher 实例添加到当前 Vue 实例的私有属性 _watcher 上（在 initLifecycle 时，vm._watcher 被初始化为 null）

``` javascript
if (isRenderWatcher) {
  vm._watcher = this
}
```

然后将当前 Wathcer 实例 push 到 vm._watchers（在 initState 时，vm._watchers 被初始化一个空数组）。

``` javascript
vm._watchers.push(this)
```

接下来判断第四个参数 options 是否为真，做一系列处理：

``` javascript
// options
if (options) {
  this.deep = !!options.deep
  this.user = !!options.user
  this.lazy = !!options.lazy
  this.sync = !!options.sync
  this.before = options.before
} else {
  this.deep = this.user = this.lazy = this.sync = false
}
```

1、options.deep，当前实例对象是否是深度观测

比如我们使用 watch 选项观测一个对象，可以这样写：

``` javascript
export default {
  watch: {
    obj: {
      handler (newVal, oldVal) {

      },
      deep: true
    }
  }
}
```

只要 obj 对象任意一层的属性发生变化，就会执行 handler。

2、options.user，除了 Vue 内部定义的观察者(如：渲染 Watcher、计算属性 Watcher 等)之外，所有观察者都被认为是开发者定义的，这时 options.user 会自动被设置为 true。

如 Vue.prototype.$watch 中：

``` javascript
options.user = true
```

3、options.lazy，

``` javascript
this.cb = cb
this.id = ++uid // uid for batching
this.active = true
this.dirty = this.lazy // for lazy watchers
this.deps = []
this.newDeps = []
this.depIds = new Set()
this.newDepIds = new Set()
this.expression = process.env.NODE_ENV !== 'production'
  ? expOrFn.toString()
  : ''
```
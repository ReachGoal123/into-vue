上节笔记学习了 Watcher 类初始化过程，本节从 get 方法开始，学习通过 Watcher 触发收集依赖的过程。

``` javascript
this.value = this.lazy
  ? undefined
  : this.get()
```

现在重点关注 this.value = this.get() ，关于 this.lazy 的原理，可以参考之前的笔记《[initComputed函数](https://github.com/zymfe/into-vue/blob/master/doc/07%E3%80%81Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B3%BB%E5%88%97/03.3%E3%80%81initComputed%E5%87%BD%E6%95%B0.md)》

get 方法全部代码如下：

``` javascript
/**
 * Evaluate the getter, and re-collect dependencies.
 */
get () {
  pushTarget(this)
  let value
  const vm = this.vm
  try {
    value = this.getter.call(vm, vm)
  } catch (e) {
    // ... 省略
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value)
    }
    popTarget()
    this.cleanupDeps()
  }
  return value
}
```

关于 pushTarget 和 popTarget：

``` javascript
// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null
const targetStack = []

export function pushTarget (target: ?Watcher) {
  targetStack.push(target)
  Dep.target = target
}

export function popTarget () {
  targetStack.pop()
  Dep.target = targetStack[targetStack.length - 1]
}
```

从注释中可以看到，当前 Dep.target 是全局的，任意时间有且只有一个依赖被收集。

pushTarget 做了两件事：将当前 Watcher 赋值给 Dep.target，同时被 push 到 targetStack 栈中。

popTarget 做了与 pushTarget 相反的两件事，先 pop 之后，Dep.target 其实就是 undefined 了。

try 中的代码，主要用来获取 value 值，在上节笔记 10.1 中已经有详细介绍了。执行 get 方法，会读取（字符串表达式）或执行（方法） expOrFn。

下面看 finally 中的代码：

``` javascript
// "touch" every property so they are all tracked as
// dependencies for deep watching
if (this.deep) {
  traverse(value)
}
popTarget()
this.cleanupDeps()
```

Vue 默认对某个对象或数组是深度观测，但是在 watch 中，这个属性是可以配置的，具体可参考之前的笔记《[initWatch函数](https://github.com/zymfe/into-vue/blob/master/doc/07%E3%80%81Vue%E6%95%B0%E6%8D%AE%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E7%B3%BB%E5%88%97/03.4%E3%80%81initWatch%E5%87%BD%E6%95%B0.md)》。

traverse 方法位于 /src/core/instance/observer/traverse.js 文件中，涉及到的代码如下：

``` javascript
const seenObjects = new Set()

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
export function traverse (val: any) {
  _traverse(val, seenObjects)
  seenObjects.clear()
}

function _traverse (val: any, seen: SimpleSet) {
  let i, keys
  const isA = Array.isArray(val)

  // 如果 value 不是数组，不是纯对象，是不可扩展的，是一个 VNode 实例，那么直接 return
  if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {
    return
  }

  // 如果 value.__ob__ 为真，说明其已经是一个响应式对象了
  // 判断 seenObjects 中是否有 depId，如果没有，则 add，否则 return
  if (val.__ob__) {
    const depId = val.__ob__.dep.id
    // 疑点一：这个地方为什么要做这个判断，代码后面有详述。
    if (seen.has(depId)) {
      return
    }
    seen.add(depId)
  }

  // 如果 value 是一个数组 或 对象，则递归执行 _traverse 即可
  // 看似 _traverse 方法没有做什么实际的事情，最后在 traverse 方法中还把 seenObj 都 clear 清空了
  // 但 deep 深度观察的目的已经在这个过程中达到了
  // 疑点二：为什么呢？代码后面有详述。
  if (isA) {
    i = val.length
    while (i--) _traverse(val[i], seen)
  } else {
    keys = Object.keys(val)
    i = keys.length
    while (i--) _traverse(val[keys[i]], seen)
  }
}
```

好了，现在就来解释上面的两个疑点。


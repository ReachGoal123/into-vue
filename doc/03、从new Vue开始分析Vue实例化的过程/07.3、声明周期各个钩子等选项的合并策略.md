### 声明周期各个钩子等选项的合并策略

对于 beforeCreate 、 created 、beforeMount ... 等声明周期钩子函数来讲，它们的合并策略是相同的，但不是 mergeAssets，以 created 为例：

![image](https://github.com/zymfe/into-vue/blob/master/example/mergeOptions/8.jpg)

可以看到，声明周期钩子函数使用的合并策略函数是 mergeHook，它同样被定义在 src/core/util/options.js 文件中：

``` javascript
/**
 * Hooks and props are merged as arrays.
 */
function mergeHook (
  parentVal: ?Array<Function>,
  childVal: ?Function | ?Array<Function>
): ?Array<Function> {
  return childVal
    ? parentVal
      ? parentVal.concat(childVal)
      : Array.isArray(childVal)
        ? childVal
        : [childVal]
    : parentVal
}

LIFECYCLE_HOOKS.forEach(hook => {
  strats[hook] = mergeHook
})
```
合并过程是：连续判断 parentVal 和 childVal 是否存在，最终返回的是数组，数组中包括 parentVal 和 childVal 中 对一个的声明周期钩子函数，断点中看下：

![image](https://github.com/zymfe/into-vue/blob/master/example/mergeOptions/9.jpg)

合并为数组之后，每个组件中执行各个声明周期函数，其实就是通过 callhook 函数遍历当前数组，挨个执行如 created 函数：

``` javascript
callHook(vm, 'beforeCreate')
callHook(vm, 'created')
callHook(vm, 'beforeMount')
// ... 等等
```

callhook 方法在后面组件相关笔记中详细介绍。

### props 、methods、inject、computed 等选项的合并策略：

``` javascript
/**
 * Other object hashes.
 */
strats.props =
strats.methods =
strats.inject =
strats.computed = function (
  parentVal: ?Object,
  childVal: ?Object,
  vm?: Component,
  key: string
): ?Object {
  if (childVal && process.env.NODE_ENV !== 'production') {
    assertObjectType(key, childVal, vm)
  }
  if (!parentVal) return childVal
  const ret = Object.create(null)
  extend(ret, parentVal)
  if (childVal) extend(ret, childVal)
  return ret
}
```

代码很简单，parentVal 中的选项放到 res 的原型上，childVal 中的选项放到 res 内部属性上，中间通过 assertObjectType 方法做了个判断，代码如下：

``` javascript
function assertObjectType (name: string, value: any, vm: ?Component) {
  if (!isPlainObject(value)) {
    warn(
      `Invalid value for option "${name}": expected an Object, ` +
      `but got ${toRawType(value)}.`,
      vm
    )
  }
}
```

规定 methods 等选项的 key 必须是对象，否则在开发环境会报警告。

### 注意
本文最后编辑于2018/12/03，技术更替飞快，文中部分内容可能已经过时，如有疑问，可在线提issue。